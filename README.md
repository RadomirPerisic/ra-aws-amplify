# `ra-data-appsync`

ðŸš¨ Work in progress. Use in production at your own risk!
Feel free to [contribute](#contributing) though to get it there though. I love contributors.

> Easily bootstrap an admin interface for your AppSync APIs.

## Why m8?

AWS AppSync is a great tool for generating GraphQL APIs that string together AWS resources. Amplify is a great tool for bootstrapping app backends so you can focus on building features.

What they don't do, is provide an easy admin interface to manage this data. Enter [`react-admin`](https://github.com/marmelab/react-admin) and this package, **`ra-data-appsync`**.

## What's in this package?

- [Installation](#installation)
- [Usage](#usage)
- [Sign in with `Auth`](#signin-with-auth)
- [Authenticating `API` with `Auth`](#authenticating-api)
- [Image Upload with `Storage`](#image-upload)
- [Pagination using `nextToken`](#pagination-using-nexttoken)

## Whats missing and needs help?

- Filtering, sorting of get & list
- Multiple image/file upload
- Recursively updating connections

[Start helping out!](https://github.com/mayteio/ra-data-appsync/issues)

## Installation

```bash
# pending npm release
# $ yarn create react-app amplify-backend-app
# $ cd amplify-backend-app
# $ yarn add react-admin ra-data-appsync aws-amplify

# after release on NPM
git clone https://github.com/mayteio/ra-data-appsync.git src/ra-data-appsync
$ amplify add api # run through the setup
$ amplify push # will generate aws-exports.js
$ yarn start
```

Example schema:

```graphql
type Post @model {
  id: ID!
  title: String!
  content: String
}
```

## Usage

```javascript
// buildDataProvider.js
import { buildAppsyncProvider } from 'ra-data-appsync';

// import files generated by @aws-amplify/cli for use
import config from './aws-exports';
import schema from './graphql/schema.json';
import * as queries from './graphql/queries';
import * as mutations from './graphql/mutations';

export const buildDataProvider = async () =>
  await buildAppsyncProvider({
    endpoint: config.aws_appsync_graphqlEndpoint,
    schema: schema.data,
    auth: {
      url: config.aws_appsync_graphqlEndpoint,
      region: config.aws_appsync_region,
      auth: {
        type: config.aws_appsync_authenticationType,
        apiKey: config.aws_appsync_apiKey,
      },
    },
    queries,
    mutations,
  });
```

```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { Admin, Resource, ListGuesser } from 'react-admin';
import { buildDataProvider } from './dataProvider';

function App() {
  const [dataProvider, setDataProvider] = useState();
  useEffect(() => {
    // create it in an effect so you can re-create it if using Auth.
    buildDataProvider().then(dataProvider =>
      setDataProvider(() => dataProvider)
    );
  }, []);

  return dataProvider ? (
    <Admin dataProvider={dataProvider}>
      <Resource name="Post" list={ListGuesser} />
    </Admin>
  ) : (
    <>Loading</>
  );
}

export default App;
```

[Screenshot of working app, pending https://github.com/marmelab/react-admin/issues/4444]

## Sign in with `Auth`

An `authProvider` is exported that works with both cognito pools and federated sign-in. If you're just after simple cognito authentication, you can pass the authProvider directly into your admin component:

```js
import React from 'react';
import { Admin, Resource, ListGuesser } from 'react-admin';
import { authProvider } from 'ra-data-appsync';

export const App = () => {
  // don't forget your dataProvider stuff
  return (
    <Admin authProvider={authProvider}>
      <Resource name="Post" list={ListGuesser} />
    </Admin>
  );
};
```

Federated sign in requires a bit of custom work, so you need to use the [`useLogin` hook](https://marmelab.com/react-admin/Authentication.html#customizing-the-login-and-logout-components) exposed by `react-admin`, passing in `federated` and `provider` properties. Your Login components might look like this:

```js
import React from 'react';
import { Login, useLogin } from 'react-admin';
import { Button } from '@material-ui/core';

// <LoginForm />
const LoginForm = () => {
  const login = useLogin();
  const handleLogin = () => login({ federated: true, provider: 'google' });
  return <Button onClick={handleLogin}>Login with Google</Button>;
};

// <LoginPage />
const LoginPage = props => <Login {...props} loginForm={<LoginForm />} />;

// <App />
const App = () => <Admin authProvider={authProvider} loginPage={LoginPage} />;
```

You also get access to the user groups via `usePermissions` hook when you use this `authProvider`.

```js
import { usePermissions } from 'react-admin';

const { permissions } = usePermissions();
console.log(permissions); // => { identityId: "...", groups: ['admin', 'user'] }
```

## Authenticating `API` with `Auth`

All the auth options get passed to the `createAppSyncLink` link function from `aws-amplify`, so you can auth using cognito pools too. Just be sure to rebuild the dataProvider _after_ you've authed with `Auth.currentAuthenticatedUser()`.

```js
// buildDataProvider.js
export const buildDataProvider = async () =>
  await buildAppsyncProvider({
    endpoint: config.aws_appsync_graphqlEndpoint,
    schema: schema.data,
    auth: {
      url: config.aws_appsync_graphqlEndpoint,
      region: config.aws_appsync_region,
      auth: {
        // pass in credentials and JWT token.
        type: config.aws_appsync_authenticationType,
        credentials: () => Auth.currentCredentials(),
        jwtToken: async () =>
          (await Auth.currentSession()).getAccessToken().getJwtToken(),
      },
    },
    queries,
    mutations,
  });
```

## File Upload

This package exposes `<S3Input />` and `<S3ImageField />` components to help you deal with image & file upload. Before you do, your schema must include an `S3Object` type where you want your file upload to be:

```graphql
type Post @model {
  id: ID!
  title: String!
  content: String
  featureImage: S3Object
}

type S3Object {
  key: String!
  region: String
  bucket: String
  identityId: String
}
```

Your `<CreatePost />` might look something like the following:

```js
// CreatePost.js
import React from 'react';
import { Create, SimpleForm, TextInput } from 'react-admin';
import { S3Input } from '../ra-data-appsync/ra-data-appsync.cjs.development';

export const CreateApp: React.FC = props => {
  return (
    <Create {...props}>
      <SimpleForm>
        <TextInput source="title" />
        <TextInput source="content" multiline />
        <S3Input source="featureImage" accept="image/*" multiple={false} />
      </SimpleForm>
    </Create>
  );
};
```

If you want to use the Image in your `<List />` component, you can use `<S3ImageField />` passing, in this example, the `featureImage` field as the source:

```js
import React from 'react';
import { List, Datagrid, TextField } from 'react-admin';
import { S3ImageField } from 'ra-data-appsync';

export const ListPosts = props => {
  return (
    <List {...props}>
      <Datagrid rowClick="edit">
        <S3ImageField source="coverImage" />
        <TextField source="title" />
        <TextField source="content" />
      </Datagrid>
    </List>
  );
};
```

### Protected, Private files

You can pass in the `level` option as a prop to S3Input (one of `public`, `protected`, and `private`) and that will get passed on to `Storage`. If you do this, it's important to either use the `authProvider` from this package, or in your custom `authProvider` pass the `identityId` into `getPermissions`:

```js
export const authProvider = {
  ...
  getPermissions: () =>
    Promise.all([
      Auth.currentCredentials(),
      Auth.currentAuthenticatedUser(),
    ]).then(([{ identityId }, use]) => ({
      identityId,
      // this allows you to check which groups the user is in too! Booya, bonus.
      groups: user.signInUserSession.accessToken.payload['cognito:groups'],
    })),
}
```

## Pagination using `nextToken`

This package also exports some helpers and components for handling pagination specific to dynamodb - which has no concept of totals or pages. You can [hack around that fact](https://stackoverflow.com/questions/55737518/how-to-paginate-react-admin-lists-when-the-total-is-unknown), or just embrace it and use next/prev as described in that link:

```js
// App.js
import { nextTokenReducer } from 'ra-data-appsync';
import { PostsList } from './PostsList';
...

export const App = () => (
  <Admin ... customReducers={{nextToken: nextTokenReducer }}>
    <Resource name="Post" list={PostsList}>
  </Admin>
)

// PostsList.js
import { List, ... } from 'react-admin';
import { RaAmplifyPagination } from 'ra-data-appsync';

export const PostsList = props => (
  <List {...props} pagination={<RaAppSyncPagination />}>
    ...
  </List>
)
```

## Contributing

Did you learn something about integrating `react-admin` with AWS Amplify on a private project? Open source only works because people like you help people like me create awesome things and share our knowledge. Any help with this package is much appreciated, whether it's knowledge, tests, improving types, additional components, optimisations, solutions, etc. Just create an issue and let's get started!

## License

[MIT]()
